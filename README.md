# 数据结构与算法

## Data Structure

### Stack

栈结构是一种连续的内存，stack pointer 从高地址位开始，每入栈一个数据sp向低位移动数据内存长度的字节，如果栈容量按照一个数据内存长度作为单位，那么入栈一个数据，栈容量减一。当count为0时栈满，sp位于栈内存最低位。

栈的设计结构中，内存地址连续，栈指针从最高地址开始，所以进栈相当于站指针下移，出栈相当于栈指针上移，新入栈的数据总是位于站指针的上方(假设高内存地址在上，0内存地址在下)，因此出栈过程中，我们只需要将指针向高位移动（上移），因此最先入栈的数据也最先出栈。

### Queue

#### forward_list

* 单向链表，只能从队尾入队，从队首出队。

![image-20230818115303131](./images/image-20230818115303131.png)

* methods
  * push
    * push_end：只允许在数据末尾增加节点，复杂度O(1)
  * ~~insert~~
  * pop
    * pop_front：只允许从链表头删除节点，复杂度O(1)
* 序列实现
  * 如果是使用Array实现单向链表，这样的单向链表支持random access，还支持O(1)下标访问，在任一节点可以随意前后移动，缺点是在列表初始化的时候就固定了大小，扩容操作复杂度高需要O(n)数据拷贝，所以我认为这种实现方式已经不算是一个单向链表，缺失了链表的基本特性--随意扩容，这种实现方式最多算是对Array的数据读写、删除的一种限制。
* 链式实现
  * 链式实现方式，是native的实现方式。保留了链表原本的特性，可以无限的在链表尾部增加节点，同样继承了链表的一些缺陷，查找数据需要从Head端开始逐个遍历，为了提升append的速度，一般在实现过程中会用Tail保存最后一个节点，用于直接添加新的节点。

#### deque（double-end queue）

* 双端链表，允许从链表两端添加、删除节点。链式存储的双端链表具有Stack和queue两者的方法。所以在有一些实现上，都是以deque作为底层数据结构，然后再对其方法进行封装。双端队列的应用有很多，浏览器页面访问记录（访问当期页面的前一个页面或者后一个页面）、用于任务调度算法等等。

* methods

  * push
    * push_front：在链表头插入节点 O(1)
    * push_end：在链表尾部插入节点 O(1)

  * pop
    * pop_front：删除头部节点 O(1)
    * pop_end：删除尾部节点O(1)

#### list(double linked list)

* 双向链表，每个节点有需要三块内存区域，第一块用与保存前向节点地址，第二块用作当前节点的数据存储，第三块用于保存后一个节点地址。这种数据结构支持在任一位置删除或插入节点，用于保存数据不稳定需要
* ![image-20230818145123884](./images/image-20230818145123884.png)
* methods
  * insert：支持在任意位置插入数据 O(1)
  * delete：删除任意位置节点 O(1)
* 双向链表相比与单向链表在使用上更具有灵活性，对于不确定长度的数据保存和删除都非常方便，唯一的缺点就是占用内存空间较大，在很多嵌入式设备会使用单向链表封装成双向链表使用以节约内存。

### Heap

* Binary Heap

### Hash

### Tree

* Binary Tree
* Binary Search Tree
* AVL Tree


## Algorithm

### Search

* Linear search

* Binary Search

### Sort

* bubble sort
* select sort
* insert sort
* shell sort
* merge sort
* quick sort